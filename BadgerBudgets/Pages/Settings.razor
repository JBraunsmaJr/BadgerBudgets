@page "/settings"
@using BadgerBudgets.Services
@using BadgerBudgets.Extensions
@inject StatementService StatementService
@inject IJSRuntime RuntimeService

<PageTitle>Settings</PageTitle>

<MudContainer>
    <MudGrid>
        <MudItem>
            <MudFileUpload Accept=".csv,.json" T="IBrowserFile" FilesChanged="OnFileUpload">
                <ButtonTemplate>
                    <MudButton HtmlTag="label"
                               Variant="Variant.Filled"
                               Color="Color.Primary"
                               StartIcon="@Icons.Material.Filled.CloudUpload"
                               for="@context.Id">
                        Upload Statement
                    </MudButton>
                </ButtonTemplate>
            </MudFileUpload>        
        </MudItem>
        <MudItem>
            <MudButton Disabled="!StatementService.HasMappings" 
                       IconClass="@Icons.Material.Filled.Download" 
                       Variant="Variant.Filled"
                       Color="Color.Info"
                       OnClick="@DownloadConfiguration">Download Mappings</MudButton>        
        </MudItem>
        
        <MudItem xs="12">
            <MudText Typo="Typo.body1">
                Every institution has different column headers. Upload a statement then map columns! Too easy!
            </MudText>        
        </MudItem>
    </MudGrid>
</MudContainer>

@if (!_hasUploadedMappings)
{
    <MudGrid Spacing="3" Style="padding: 16px;">
        
            @foreach (var headerItem in _header)
            {
                <MudItem xs="3">
                    <MudSelect T="ColumnType" Label="@headerItem" AnchorOrigin="Origin.BottomCenter" @ref="@Ref" >
                        <MudSelectItem Value="@ColumnType.None"></MudSelectItem>
                        <MudSelectItem Value="ColumnType.TransactionDate">Transaction Date</MudSelectItem>
                        <MudSelectItem Value="ColumnType.Amount">Amount</MudSelectItem>
                        <MudSelectItem Value="ColumnType.Credit">Credit</MudSelectItem>
                        <MudSelectItem Value="ColumnType.Debit">Debit</MudSelectItem>
                        <MudSelectItem Value="ColumnType.LineItem">Description</MudSelectItem>
                        <MudSelectItem Value="ColumnType.Category">Category</MudSelectItem>
                        <MudSelectItem Value="ColumnType.CreditDebitCombined">Credit & Debit</MudSelectItem>
                    </MudSelect>
                </MudItem>
            }
    </MudGrid>
}
 
<MudContainer>
    <MudCard Elevation="2">
        <MudCardHeader>
            <MudText Typo="Typo.h6">File Contents</MudText>
        </MudCardHeader>
        <MudCardContent>
            <MudTable Striped Elevation="3" Dense Items="_fileContents">
                <HeaderContent>
                    @foreach (var headerItem in _header)
                    {
                        <MudTh>@headerItem</MudTh>
                    }
                </HeaderContent>
                <RowTemplate>
                    @{
                        foreach (var item in context)
                        {
                            <MudTd>@item</MudTd>
                        }
                    }
                </RowTemplate>
            </MudTable>
        </MudCardContent>
    </MudCard>
</MudContainer>

@code {
    private HashSet<string> _acceptableExtensions = new() { ".csv", ".txt" };
    private Dictionary<string, MudSelect<ColumnType>> _mappingSelects = new();

    private Dictionary<string, ColumnType> _columnTypes = new()
    {
        ["Transaction Date"] = ColumnType.TransactionDate,
        ["Line Item"] = ColumnType.LineItem,
        ["Amount"] = ColumnType.Amount,
        ["Debit"] = ColumnType.Debit,
        ["Credit"] = ColumnType.Credit,
        ["Category"] = ColumnType.Category,
        ["Credit & Debit"] = ColumnType.CreditDebitCombined
    };

    MudSelect<ColumnType> Ref
    {
        set
        {
            var count = _mappingSelects.Count;
            var headerText = _header[count];
            _mappingSelects.Add(headerText, value);
            
        }
    }

    private List<string[]> _fileContents = new();
    private string[] _header = Array.Empty<string>();
    private bool _hasUploadedMappings = false;
    
    async Task OnFileUpload(IBrowserFile uploadedFile)
    {
        try
        {
            var info = new FileInfo(uploadedFile.Name);
            
            if (!_acceptableExtensions.Contains(info.Extension))
                return;

            using MemoryStream memStream = new();
            await uploadedFile.OpenReadStream().CopyToAsync(memStream);
            using TextReader reader = new StreamReader(memStream);
            memStream.Position = 0;
            var contents = await reader.ReadToEndAsync();
            
            if (uploadedFile.Name == "column-mappings.json")
            {
                var mappings = Newtonsoft.Json.JsonConvert.DeserializeObject<Dictionary<ColumnType, int>>(contents); 
                await StatementService.SetMappings(mappings ?? new());
                _hasUploadedMappings = true;
                StateHasChanged();
                return;
            }
            
            var lines = contents.Split('\n');
            _header = lines[0].Split(',');

            foreach (var line in lines[1..])
            {
                if (string.IsNullOrWhiteSpace(line.Trim()))
                    continue;
                var parts = line.Split(',');
                _fileContents.Add(parts);
            }
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        foreach (var pair in _mappingSelects)
            pair.Value.ValueChanged = EventCallback.Factory.Create<ColumnType>(this, () => OnHeaderLinkChange(pair.Key));
    }

    private async Task OnHeaderLinkChange(string headerText)
    {
        var selectedItem = _mappingSelects[headerText].Value;
        var headerIndex = _header.Index(x => x == headerText);
        await StatementService.UpdateMapping(selectedItem, headerIndex);
    }

    private async Task DownloadConfiguration()
    {
        var file = System.Text.Encoding.UTF8.GetBytes(StatementService.SerializeMappings());
        await RuntimeService.InvokeVoidAsync("BlazorDownloadFile", "column-mappings.json", "text/json", file);
    }

}
